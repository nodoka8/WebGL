<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>myhomepage</title>
    <link rel="stylesheet" href="stylesheet.css">
    <script src="bgscript.js" type="text/javascript"></script>
    <script src="script.js" type="text/javascript"></script>
    <script src="minMatrix.js" type="text/javascript"></script>
    <script src="minMatrixb.js" type="text/javascript"></script>
    <script id="vs" type="x-shader/x-vertex">
      attribute vec3 position;

      void main(void){
      	gl_Position = vec4(position, 1.0);
      }
    </script>

    <script id="fs" type="x-shader/x-fragment">
      precision mediump float;

      uniform float time;
      uniform vec2  mouse;
      uniform vec2  resolution;

      const float PI = 3.14159265;
      const float angle = 60.0;
      const float fov = angle * 0.5 * PI / 180.0;
      vec3  cPos = vec3(0.0, 0.0, 2.0);
      const float sphereSize = 0.5;
      vec3 lightDir = vec3(1, -0.577, 0.577);

      vec3 trans(vec3 p){
          return mod(p, 4.0) - 2.0;
      }

      float distanceFunc(vec3 p){
        vec3 q = abs(trans(p));
        return length(max(q - vec3(0.5, 0.5, 0.5), 0.0)) - 0.1;
      }


      vec3 getNormal(vec3 p){
          float d = 0.0001;
          return normalize(vec3(
              distanceFunc(p + vec3(  d, 0.0, 0.0)) - distanceFunc(p + vec3( -d, 0.0, 0.0)),
              distanceFunc(p + vec3(0.0,   d, 0.0)) - distanceFunc(p + vec3(0.0,  -d, 0.0)),
              distanceFunc(p + vec3(0.0, 0.0,   d)) - distanceFunc(p + vec3(0.0, 0.0,  -d))
          ));
      }

      vec3 rotate(vec3 p, float angle, vec3 axis){
          vec3 a = normalize(axis);
          float s = sin(angle);
          float c = cos(angle);
          float r = 1.0 - c;
          mat3 m = mat3(
              a.x * a.x * r + c,
              a.y * a.x * r + a.z * s,
              a.z * a.x * r - a.y * s,
              a.x * a.y * r - a.z * s,
              a.y * a.y * r + c,
              a.z * a.y * r + a.x * s,
              a.x * a.z * r + a.y * s,
              a.y * a.z * r - a.x * s,
              a.z * a.z * r + c
          );
          return m * p;
      }

      void main(void){
          lightDir.x *= sin(time * 2.0);
          lightDir.y *= cos(time * 1.5);

          // fragment position
          vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);

          // ray
          vec3 ray = normalize(vec3(sin(fov) * p.x, sin(fov) * p.y, -cos(fov)));


          ray = rotate(ray,mouse.x * 3.0,vec3(0.0,1.0,0.0));
          ray = rotate(ray,mouse.y * 3.0,vec3(1.0,0.0,0.0));


          // marching loop
          float distance = 0.0;
          float rLen = 0.0;
          vec3  rPos = cPos;
          for(int i = 0; i < 64; i++){
              distance = distanceFunc(rPos);
              rLen += distance;
              rPos = cPos + ray * rLen;
          }

          // hit check
          if(abs(distance) < 0.001){
              vec3 normal = getNormal(rPos);
              float diff = clamp(dot(lightDir,normal),0.0,1.0) + 0.1;
              gl_FragColor = vec4(vec3(diff), 1.0);
          }else{
              gl_FragColor = vec4(vec3(0.0), 1.0);
          }
      }

    </script>


    <script id="bvs" type="x-shader/x-vertex">
      attribute vec3 position;

      void main(void){
        gl_Position = vec4(position, 1.0);
      }
    </script>

    <script id="bfs" type="x-shader/x-fragment">
      precision mediump float;

      uniform float time;
      uniform vec2  mouse;
      uniform vec2  resolution;


      const int   oct  = 8;
      const float per  = 0.5;
      const float PI   = 3.1415926;
      const float cCorners = 1.0 / 16.0;
      const float cSides   = 1.0 / 8.0;
      const float cCenter  = 1.0 / 4.0;

      // 補間関数
      float interpolate(float a, float b, float x){
          float f = (1.0 - cos(x * PI)) * 0.5;
          return a * (1.0 - f) + b * f;
      }

      // 乱数生成
      float rnd(vec2 p){
          return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
      }

      // 補間乱数
      float irnd(vec2 p){
          vec2 i = floor(p);
          vec2 f = fract(p);
          vec4 v = vec4(rnd(vec2(i.x,       i.y      )),
                        rnd(vec2(i.x + 1.0, i.y      )),
                        rnd(vec2(i.x,       i.y + 1.0)),
                        rnd(vec2(i.x + 1.0, i.y + 1.0)));
          return interpolate(interpolate(v.x, v.y, f.x), interpolate(v.z, v.w, f.x), f.y);
      }

      // ノイズ生成
      float noise(vec2 p){
          float t = 0.0;
          for(int i = 0; i < oct; i++){
              float freq = pow(2.0, float(i));
              float amp  = pow(per, float(oct - i));
              t += irnd(vec2(p.x / freq, p.y / freq)) * amp;
          }
          return t;
      }

      // シームレスノイズ生成
      float snoise(vec2 p, vec2 q, vec2 r){
          return noise(vec2(p.x,       p.y      )) *        q.x  *        q.y  +
                 noise(vec2(p.x,       p.y + r.y)) *        q.x  * (1.0 - q.y) +
                 noise(vec2(p.x + r.x, p.y      )) * (1.0 - q.x) *        q.y  +
                 noise(vec2(p.x + r.x, p.y + r.y)) * (1.0 - q.x) * (1.0 - q.y);
      }

      void main(void){
          // noise
          vec2 t = gl_FragCoord.xy + vec2(time * 10.0);
          float n = noise(t);

          // seamless noise
      //	const float map = 256.0;
      //	vec2 t = mod(gl_FragCoord.xy + vec2(time * 10.0), map);
      //	float n = snoise(t, t / map, vec2(map));

          gl_FragColor = vec4(vec3(n)*vec3(0.1,0.1,0.4), 1.0);
      }

    </script>

  </head>
  <body>

    <div class="canvas-wrapper">
      <canvas id="background"></canvas>
      <canvas id="canvas"></canvas>
    </div>

    <div class= "header">

      <!--<img class="titleimg" src="img/title.png">-->
      <!--<h1 class="title">portfolio</h1>-->

      <p><input type="checkbox" id="check" checked><label for="check"> auto run</label></p>

    </div>


  </body>
</html>
